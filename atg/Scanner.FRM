(*  scanner module generated by Coco-R *)
MODULE -->modulename;

IMPORT Texts, SYSTEM;

CONST
	EOL = 0AX;
	EOF = 0X;
	maxLexLen = 127;
-->declarations

TYPE
	ErrorProc* = PROCEDURE (n: INTEGER; pos: LONGINT);
	StartTable = ARRAY 128 OF INTEGER;
  
VAR
	src*: Texts.Text;  (*source text. To be set by the main pgm*)
	pos*: LONGINT;  (*position of current symbol*)
	line*, col*, len*: INTEGER;  (*line, column, length of current symbol*)
	nextPos*: LONGINT;  (*position of lookahead symbol*)
	nextLine*, nextCol*, nextLen*: INTEGER;  (*line, column, length of lookahead symbol*)
	errors*: INTEGER;  (*number of errors detected*)
	Error*: ErrorProc;

	ch: CHAR;        (*current input character*)
	r: Texts.Reader;	(*global reader*)
	chPos: LONGINT;	(*position of current character*)
	chLine: INTEGER;  (*current line number*)
	lineStart: LONGINT;  (*start position of current line*)
	apx: INTEGER;     (*length of appendix*)
	oldEols: INTEGER;     (*nr. of EOLs in a comment*)

	start: StartTable;  (*start state for every character*)


PROCEDURE NextCh; (*return global variable ch*)
BEGIN
	Texts.Read(r, ch); INC(chPos);
	IF ch = EOL THEN INC(chLine); lineStart := chPos + 1 END
END NextCh;


PROCEDURE Comment(): BOOLEAN;
	VAR level, startLine: INTEGER; oldLineStart: LONGINT;
BEGIN (*Comment*)
	level := 1; startLine := chLine; oldLineStart := lineStart;
-->comment
END Comment;


PROCEDURE Get*(VAR sym: INTEGER);
VAR state: INTEGER; lexeme: ARRAY maxLexLen+1 OF CHAR;

	PROCEDURE CheckLiteral;
	BEGIN
		IF nextLen < maxLexLen THEN lexeme[nextLen] := 0X END;
-->literals
	END CheckLiteral;
	
BEGIN
-->GetSy1
	IF ch > 7FX THEN ch := " " END;
	pos := nextPos; col := nextCol; line := nextLine; len := nextLen;
	nextPos := chPos; nextCol := SHORT(chPos - lineStart); nextLine := chLine; nextLen := 0;
	state := start[ORD(ch)]; apx := 0;
	LOOP
		IF nextLen < maxLexLen THEN lexeme[nextLen] := ch END;
		INC(nextLen);
		NextCh;
		IF state > 0 THEN
			CASE state OF
-->GetSy2
			END (*CASE*)
		ELSE sym := noSym; RETURN (*NextCh already done*)
		END (*IF*)
	END (*LOOP*)
END Get;
	

PROCEDURE GetName*(pos: LONGINT; len: INTEGER; VAR s: ARRAY OF CHAR);
	VAR i: INTEGER; r: Texts.Reader;
BEGIN
	Texts.OpenReader(r, src, pos);
	IF len >= LEN(s) THEN len := SHORT(LEN(s)) - 1 END;
	i := 0; WHILE i < len DO Texts.Read(r, s[i]); INC(i) END;
	s[i] := 0X
END GetName;
	
PROCEDURE StdErrorProc* (n: INTEGER; pos: LONGINT);
BEGIN INC(errors) END StdErrorProc;

PROCEDURE Reset* (t: Texts.Text; pos: LONGINT; errProc: ErrorProc);
BEGIN
	src := t; Error := errProc;
	Texts.OpenReader(r, src, pos);
	chPos := pos - 1; chLine := 1; lineStart := 0;
	oldEols := 0; apx := 0; errors := 0;
	NextCh
END Reset;

BEGIN
-->initialization
END -->modulename.
